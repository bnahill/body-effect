/*
 * This source file contains a Verilog description of a DFT IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2010 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 4 complex words per cycle
//   Throughput: one transform every 1 cycles
//   Latency: 4 cycles

//   Resources required:
//     16 adders (8 x 8 bit)

// Generated on Wed Nov 07 18:48:57 EST 2012

// Latency: 4 clock cycles
// Throughput: 1 transform every 1 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 1 cycles.  This means that
// 1 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 4 cycles.  This means that
// the 'next_out' will be asserted 4 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.

module dft_top(clk, next, next_out,
	X0, Y0,
	X1, Y1,
	X2, Y2,
	X3, Y3,
	X4, Y4,
	X5, Y5,
	X6, Y6,
	X7, Y7);

   output next_out;
   input clk, next;

   input [7:0] X0, X1, X2, X3, X4, X5, X6, X7;

   output [7:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7;

	wire [7:0] t0_0;
	wire [7:0] t0_1;
	wire [7:0] t0_2;
	wire [7:0] t0_3;
	wire [7:0] t0_4;
	wire [7:0] t0_5;
	wire [7:0] t0_6;
	wire [7:0] t0_7;
	wire next_0;
	wire [7:0] t1_0;
	wire [7:0] t1_1;
	wire [7:0] t1_2;
	wire [7:0] t1_3;
	wire [7:0] t1_4;
	wire [7:0] t1_5;
	wire [7:0] t1_6;
	wire [7:0] t1_7;
	wire next_1;
	wire [7:0] t2_0;
	wire [7:0] t2_1;
	wire [7:0] t2_2;
	wire [7:0] t2_3;
	wire [7:0] t2_4;
	wire [7:0] t2_5;
	wire [7:0] t2_6;
	wire [7:0] t2_7;
	wire next_2;
	assign t0_0 = X0;
	assign Y0 = t2_0;
	assign t0_1 = X1;
	assign Y1 = t2_1;
	assign t0_2 = X2;
	assign Y2 = t2_2;
	assign t0_3 = X3;
	assign Y3 = t2_3;
	assign t0_4 = X4;
	assign Y4 = t2_4;
	assign t0_5 = X5;
	assign Y5 = t2_5;
	assign t0_6 = X6;
	assign Y6 = t2_6;
	assign t0_7 = X7;
	assign Y7 = t2_7;
	assign next_0 = next;
	assign next_out = next_2;

	stage0 xstage0(.clk(clk), .next_in(next_0), .next_out(next_1),
		.X0_in(t0_0), .Y0(t1_0),
		.X1_in(t0_1), .Y1(t1_1),
		.X2_in(t0_2), .Y2(t1_2),
		.X3_in(t0_3), .Y3(t1_3),
		.X4_in(t0_4), .Y4(t1_4),
		.X5_in(t0_5), .Y5(t1_5),
		.X6_in(t0_6), .Y6(t1_6),
		.X7_in(t0_7), .Y7(t1_7));


	stage1 xstage1(.clk(clk), .next_in(next_1), .next_out(next_2),
		.X0(t1_0), .Y0(t2_0),
		.X1(t1_1), .Y1(t2_1),
		.X2(t1_2), .Y2(t2_2),
		.X3(t1_3), .Y3(t2_3),
		.X4(t1_4), .Y4(t2_4),
		.X5(t1_5), .Y5(t2_5),
		.X6(t1_6), .Y6(t2_6),
		.X7(t1_7), .Y7(t2_7));
endmodule

module stage0(clk, next_in, next_out,
	X0_in, Y0,
	X1_in, Y1,
	X2_in, Y2,
	X3_in, Y3,
	X4_in, Y4,
	X5_in, Y5,
	X6_in, Y6,
	X7_in, Y7);

	output next_out;
	input clk, next_in;
	input [7:0] X0_in, X1_in, X2_in, X3_in, X4_in, X5_in, X6_in, X7_in;

	wire   [7:0] X0, X1, X2, X3, X4, X5, X6, X7;

	output [7:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7;

	wire signed [7:0] Y0;
	wire signed [7:0] Y1;
	wire signed [7:0] Y2;
	wire signed [7:0] Y3;
	wire signed [7:0] Y4;
	wire signed [7:0] Y5;
	wire signed [7:0] Y6;
	wire signed [7:0] Y7;


	addfxp #(8, 1) add14299(.a(X0), .b(X4), .clk(clk), .q(Y0));
	addfxp #(8, 1) add14314(.a(X1), .b(X5), .clk(clk), .q(Y1));
	subfxp #(8, 1) sub14328(.a(X0), .b(X4), .clk(clk), .q(Y2));
	subfxp #(8, 1) sub14342(.a(X1), .b(X5), .clk(clk), .q(Y3));
	addfxp #(8, 1) add14373(.a(X2), .b(X6), .clk(clk), .q(Y4));
	addfxp #(8, 1) add14388(.a(X3), .b(X7), .clk(clk), .q(Y5));
	subfxp #(8, 1) sub14402(.a(X2), .b(X6), .clk(clk), .q(Y6));
	subfxp #(8, 1) sub14416(.a(X3), .b(X7), .clk(clk), .q(Y7));


	flop #8 reg_input0(.d(X0_in), .q(X0), .clk(clk));
	flop #8 reg_input1(.d(X1_in), .q(X1), .clk(clk));
	flop #8 reg_input2(.d(X2_in), .q(X2), .clk(clk));
	flop #8 reg_input3(.d(X3_in), .q(X3), .clk(clk));
	flop #8 reg_input4(.d(X4_in), .q(X4), .clk(clk));
	flop #8 reg_input5(.d(X5_in), .q(X5), .clk(clk));
	flop #8 reg_input6(.d(X6_in), .q(X6), .clk(clk));
	flop #8 reg_input7(.d(X7_in), .q(X7), .clk(clk));


	flop #1 next_delay(.d(next_in), .q(next_out), .clk(clk));
endmodule



module stage1(clk, next_in, next_out,
	X0, Y0,
	X1, Y1,
	X2, Y2,
	X3, Y3,
	X4, Y4,
	X5, Y5,
	X6, Y6,
	X7, Y7);

	output next_out;
	input clk, next_in;

	input  [7:0] X0, X1, X2, X3, X4, X5, X6, X7;
	output [7:0] Y0, Y1, Y2, Y3, Y4, Y5, Y6, Y7;
	
	wire signed [7:0] Y0_reg, Y1_reg, Y2_reg, Y3_reg, Y4_reg, Y5_reg, Y6_reg, Y7_reg;

	wire signed [7:0] t49;
	wire signed [7:0] t50;
	wire signed [7:0] t51;
	wire signed [7:0] t52;
	wire signed [7:0] Y0;
	wire signed [7:0] Y1;
	wire signed [7:0] Y4;
	wire signed [7:0] Y5;
	wire signed [7:0] t53;
	wire signed [7:0] t54;
	wire signed [7:0] t55;
	wire signed [7:0] t56;
	wire signed [7:0] Y2;
	wire signed [7:0] Y3;
	wire signed [7:0] Y6;
	wire signed [7:0] Y7;


	addfxp #(8, 1) add14450(.a(X0), .b(X4), .clk(clk), .q(Y0_reg));
	addfxp #(8, 1) add14465(.a(X1), .b(X5), .clk(clk), .q(Y1_reg));
	subfxp #(8, 1) sub14479(.a(X0), .b(X4), .clk(clk), .q(Y4_reg));
	subfxp #(8, 1) sub14493(.a(X1), .b(X5), .clk(clk), .q(Y5_reg));
	addfxp #(8, 1) add14524(.a(X2), .b(X6), .clk(clk), .q(Y2_reg));
	//addfxp #(8, 1) add14539(.a(X3), .b(X7), .clk(clk), .q(Y3_reg));
	subfxp #(8, 1) sub14539(.a(X3), .b(X7), .clk(clk), .q(Y3_reg));
	subfxp #(8, 1) sub14553(.a(X2), .b(X6), .clk(clk), .q(Y6_reg));
	//subfxp #(8, 1) sub14567(.a(X3), .b(X7), .clk(clk), .q(Y7_reg));
	addfxp #(8, 1) add14567(.a(X3), .b(X7), .clk(clk), .q(Y7_reg));


	flop #8 reg_output0(.d(Y0_reg), .q(Y0), .clk(clk));
	flop #8 reg_output1(.d(Y1_reg), .q(Y1), .clk(clk));
	flop #8 reg_output2(.d(Y2_reg), .q(Y2), .clk(clk));
	flop #8 reg_output3(.d(Y3_reg), .q(Y3), .clk(clk));
	flop #8 reg_output4(.d(Y4_reg), .q(Y4), .clk(clk));
	flop #8 reg_output5(.d(Y5_reg), .q(Y5), .clk(clk));
	flop #8 reg_output6(.d(Y6_reg), .q(Y6), .clk(clk));
	flop #8 reg_output7(.d(Y7_reg), .q(Y7), .clk(clk));


	flop #1 next_delay(.d(next_in), .q(next_out), .clk(clk));
endmodule



module flop(d, q, clk);
	parameter width = 1;
	input  [width-1:0] d;
	input  clk;
	output reg [width-1:0] q;
	
	always @(posedge clk) begin
		q <= d;
	end
endmodule



module addfxp(a, b, q, clk);
	parameter width = 16, cycles=1;

	input signed [width-1:0]  a, b;
	input                     clk;   
	output signed [width-1:0] q;

	assign q = a + b;
endmodule


module subfxp(a, b, q, clk);
	parameter width = 16, cycles=1;

	input signed [width-1:0]  a, b;
	input                     clk;   
	output signed [width-1:0] q;

	assign q = a - b;
endmodule
